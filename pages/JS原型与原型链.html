<html>
<head>
  <title>JS原型与原型链</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="402"/>
<h1>JS原型与原型链</h1>

<div>
<span><div><h3>一. 普通对象与函数对象</h3></div><div><br/></div><div>JavaScript 中，万物皆对象！但对象也是有区别的。分为<strong>普通对象和函数对象</strong>，Object 、Function 是 JS 自带的函数对象。下面举例说明：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var o1 = {};</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var o2 =new Object();</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var o3 = new f1();</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function f1(){};</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var f2 = function(){};</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var f3 = new Function('str','console.log(str)');</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"> </span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Object); //function</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Function); //function</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof f1); //function</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof f2); //function</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof f3); //function</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof o1); //object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof o2); //object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof o3); //object</span></span></div></div><div><p>在上面的例子中 o1 o2 o3 为普通对象，f1 f2 f3 为函数对象。怎么区分，其实很简单，<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的</strong>。</p><p>一定要分清楚普通对象和函数对象，下面我们会常常用到它。</p></div><div><br/></div><div><b><span style="font-size: 15px;">二. 构造函数</span></b></div><div><b><span style="font-size: 15px;"><br/></span></b></div><div>我们先复习一下构造函数的知识：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function Person(name, age, job) {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.name = name;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.age = age;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.job = job;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.sayName = function() {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">          alert(this.name)</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     }</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var person1 = new Person('Zaxlct', 28, 'Software Engineer');</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var person2 = new Person('Mick', 23, 'Doctor');</span></span></div></div><div><p>上面的例子中 person1 和 person2 都是 Person 的<strong>实例</strong>。这两个<strong>实例</strong>都有一个 <code><span style="font-family: 微软雅黑;">constructor</span></code> （构造函数）属性，该属性（是一个指针）指向 Person。 即：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>  console.log(person1.constructor == Person); //true</div><div>  console.log(person2.constructor == Person); //true</div></div><div><br/></div><div>我们要记住两个概念（构造函数，实例）：</div><div><strong>person1 和 person2 都是 构造函数 Person 的实例</strong></div><div><b><br/></b></div><div>一个公式：<br/><strong>实例的构造函数属性（constructor）指向构造函数。</strong></div><div><h3>三. 原型对象</h3><p>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个<strong>函数对象</strong>都有一个<code><span style="font-family: 微软雅黑;">prototype</span></code> 属性，这个属性指向函数的<strong>原型对象</strong>。（先用不管什么是 <code><span style="font-family: 微软雅黑;">__proto__</span></code> 第二节的课程会详细的剖析）</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>function Person() {}</div><div>Person.prototype.name = 'Zaxlct';</div><div>Person.prototype.age = 28;</div><div>Person.protetype.job = 'Software Engineer';</div><div>Person.prototype.sayName = function() {</div><div>     alert(this.name);</div><div>}</div><div>var person1 = new Person();</div><div>person1.sayName(); // 'Zaxlct'</div><div>var person2 = new Person();</div><div>person2.sayName(); // 'Zaxlct'</div><div>console.log(person1.sayname == person2.sayname); //true</div></div><div><br/></div><div><p>我们得到了本文第一个「<strong>定律</strong>」：</p><pre><span style="font-family: 微软雅黑;"><b><code><span style="font-family: 微软雅黑;">每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性</span></code></b></span></pre><hr/><p>那什么是<strong>原型对象</strong>呢？<br/>
我们把上面的例子改一改你就会明白了：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Person.prototype = {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     name: 'Zaxlct',</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     age: 28,</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     job: 'Software Engineer',</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     sayName: function() {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">                   alert(this.name);</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     }</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">}</span></span></div></div><div><p>原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 Person.prototype ，如果你还是害怕它，那就把它想想成一个字母 A： <code><span style="font-family: 微软雅黑;">var A = Person.prototype</span></code></p><hr/></div><div><br/></div><div>在上面我们给 A 添加了 四个属性：name、age、job、sayName。其实它还有一个默认的属性：<code><span style="font-family: 微软雅黑;">constructor</span></code></div><br/>
在默认情况下，所有的<strong>原型对象</strong>都会<strong>自动获得</strong>一个 <code><span style="font-family: 微软雅黑;">constructor</span></code>（构造函数）属性，这个属性（是一个<b>指针</b>）指向 <code><span style="font-family: 微软雅黑;">prototype</span></code> 属性所在的函数（Person）
<div><br/></div><div>上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 <code><span style="font-family: 微软雅黑;">constructor</span></code> 属性，这个属性是一个指针，指向 Person。即：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>Person.prototype.constructor == Person</div></div><div><br/></div><div><hr/><p>在上面第二小节《构造函数》里，我们知道<em>实例的构造函数属性（constructor）指向构造函数</em> ：<code><span style="font-family: 微软雅黑;">person1.constructor == Person</span></code></p><p>这两个「公式」好像有点联系：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">person1.constructor == Person</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Person.prototype.constructor == Person</span></span></div></div><div><p>person1 为什么有 constructor 属性？那是因为 person1 是 Person 的实例。<br/>
那 Person.prototype 为什么有 constructor 属性？？同理， Person.prototype （你把它想象成 A） 也是Person 的实例。<br/>
也就是在 Person 创建的时候，创建了一个它的实例对象并赋值给它的 prototype，基本过程如下：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var A = new Person();</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Person.prototype = A;</span></span></div></div><div><p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p><hr/><p>原型对象其实就是普通对象（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。看下面的例子：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function Person(){};</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(Person.prototype) //Person{}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Person.prototype) //Object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Function.prototype) // Function，这个特殊</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Object.prototype) // Object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Function.prototype.prototype) //undefined，它很特殊，没有prototype属性</span></span></div></div><div><p><code><span style="font-family: 微软雅黑;">Function.prototype</span></code> 为什么是函数对象呢？</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>var A = new Function ();</div><div>Function.prototype = A;</div></div><div><br/></div><div><h2><span style="font-size: 16px;">上文提到<strong>凡是通过 new Function( ) 产生的对象都是函数对象</strong>。因为 A 是函数对象，所以<code><span style="font-family: 微软雅黑;">Function.prototype</span></code> 是函数对象</span>。</h2><p><b>那原型对象是用来做什么的呢？主要作用是用于继承</b>。举个例子：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var Person = function(name){</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.name = name; // tip: 当函数执行时这个 this 指的是谁？</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">};</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Person.prototype.getName = function(){</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     return this.name; // tip: 当函数执行时这个 this 指的是谁？</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var person1 = new person('Mick');</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">person1.getName(); //Mick</span></span></div></div><div><p>从这个例子可以看出，通过给 <code><span style="font-family: 微软雅黑;">Person.prototype</span></code> 设置了一个函数对象的属性，那有 Person 的实例（person1）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p></div><div><br/></div><div>小问题，上面两个 this 都指向谁？</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var person1 = new person('Mick');</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">person1.name = 'Mick'; // 此时 person1 已经有 name 这个属性了</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">person1.getName(); //Mick</span></span></div></div><div><p>故两次 this 在函数执行时都指向 person1。</p></div><div><br/></div><div><b><span style="font-size: 15px;">四. __proto__</span></b></div><div><b><span style="font-size: 15px;"><br/></span></b></div><div>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code><span style="font-family: 微软雅黑;">__proto__</span></code> 的内置属性，<b>用于指向创建它的构造函数的原型对象</b>。<br/>
对象 person1 有一个 <code><span style="font-family: 微软雅黑;">__proto__</span></code>属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype ，所以：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;">person1.__proto__ == Person.prototype</span></span>  //指向构建它的构造函数的原型对象</div></div><div><br/></div><div>请看下图：</div><div><br/></div><div><img src="../image/JS原型与原型链_files/Image.png" type="image/png" style="height:auto;" width="701"/></div><div><p>根据上面这个连接图，我们能得到：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Person.prototype.constructor == Person;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">person1.__proto__ == Person.prototype;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">person1.constructor == Person;</span></span></div></div><div><br/></div><div><strong>不过，要明确的真正重要的一点就是，这个连接存在于实例（<code><span style="font-family: 微软雅黑;">person1</span></code>）与构造函数（<code><span style="font-family: 微软雅黑;">Person</span></code>）的原型对象（<code><span style="font-family: 微软雅黑;">Person.prototype</span></code>）之间，而不是存在于实例（<code><span style="font-family: 微软雅黑;">person1</span></code>）与构造函数（<code><span style="font-family: 微软雅黑;">Person</span></code>）之间。</strong></div><div>注意：因为绝大部分浏览器都支持__proto__属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。</div><div><br/></div><div><h3>五. 构造器</h3><p>熟悉 Javascript 的童鞋都知道，我们可以这样创建一个对象：<br/><code><span style="font-family: 微软雅黑;">var obj = {}</span></code><br/>
它等同于下面这样：<br/><code><span style="font-family: 微软雅黑;">var obj = new Object()</span></code></p></div><div><br/></div><div>obj 是构造函数（Object）的一个实例。所以：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">obj.constructor === Object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">obj.__proto__ === Object.prototype</span></span></div></div><div><p>新对象 obj 是使用 new 操作符后跟一个<strong>构造函数</strong>来创建的。构造函数（Object）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 Person 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 Object 吓倒。</p><hr/><p>同理，可以创建对象的构造器不仅仅有 Object，也可以是 Array，Date，Function等。<br/>
所以我们也可以构造函数来创建 Array、 Date、Function</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var b = new Array();</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">b.constructor === Array;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">b.__proto__ === Array.prototype;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"> </span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var c = new Date();</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">c.constructor === Date;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">c.__proto__ === Date.prototype;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var d = new Function();</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">d.constructor === Function;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">d.__proto__ === Function.prototype;</span></span></div></div><div><br/></div><div>这些构造器都是函数对象：</div><div><br/></div><div><img src="../image/JS原型与原型链_files/Image [1].png" type="image/png" style="height:auto;" width="347"/></div><div><img style="height: auto;"></img></div><div><br/></div><div style="font-weight: bold; font-size: 15px;"><br/></div><div style="font-weight: bold; font-size: 15px;">六. 原型链</div><div><p>小测试来检验一下你理解的怎么样：</p><ol><li><code><span style="font-family: 微软雅黑;">person1.__proto__</span></code> 是什么？</li><li><code><span style="font-family: 微软雅黑;">Person.__proto__</span></code> 是什么？</li><li><code><span style="font-family: 微软雅黑;">Person.prototype.__proto__</span></code> 是什么？</li><li><code><span style="font-family: 微软雅黑;">Object.__proto__</span></code> 是什么？</li><li><code><span style="font-family: 微软雅黑;">Object.prototype.__proto__</span></code> 是什么？</li></ol></div><div><br/></div><div>答案：<br/>
第一题：<br/>
因为 <code><span style="font-family: 微软雅黑;">person1.__proto__ === person1 的构造函数.prototype</span></code></div><div>因为 <code><span style="font-family: 微软雅黑;">person1的构造函数 === Person</span></code></div><div>所以 <code><span style="font-family: 微软雅黑;">person1.__proto__ === Person.prototype   //构造函数的原型</span></code></div><div><p>第二题：<br/>
因为 <code><span style="font-family: 微软雅黑;">Person.__proto__ === Person的构造函数.prototype</span></code><br/>
因为 <code><span style="font-family: 微软雅黑;">Person的构造函数 === Function</span></code><br/>
所以 <code><span style="font-family: 微软雅黑;">Person.__proto__ === Function.prototype</span></code></p><p>第三题：<br/><code><span style="font-family: 微软雅黑;">Person.prototype</span></code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。<br/>
因为一个普通对象的构造函数 === Object<br/>
所以 <code><span style="font-family: 微软雅黑;">Person.prototype.__proto__ === Object.prototype</span></code></p><p>第四题，参照第二题，因为 Person 和 Object 一样都是构造函数</p></div><div><br/></div><div>第五题：<br/><code><span style="font-family: 微软雅黑;">Object.prototype</span></code> 对象也有<strong>proto</strong>属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。</div><div><b><code><span style="font-family: 微软雅黑;">Object.prototype.__proto__ === null</span></code></b></div><div><b><br/></b></div><div><br/></div><div><b><span style="font-size: 15px;">七. 函数对象 （复习一下前面的知识点）</span></b></div><div><b><span style="font-size: 15px;"><br/></span></b></div><div><b><span style="font-size: 13px;">所有<em>函数对象</em>的__proto__都指向Function.prototype，它是一个空函数（Empty function）</span></b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Number.__proto__ === Function.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Number.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Boolean.__proto__ === Function.prototype // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Boolean.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">String.__proto__ === Function.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">String.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Object.__proto__ === Function.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Object.constructor == Function // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Function.__proto__ === Function.prototype // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Function.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Array.__proto__ === Function.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Array.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">RegExp.__proto__ === Function.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">RegExp.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Error.__proto__ === Function.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Error.constructor == Function //true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Date.__proto__ === Function.prototype    // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Date.constructor == Function //true</span></span></div></div><div><br/></div><div>JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype。如下</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Math.__proto__ === Object.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Math.construrctor == Object // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">JSON.__proto__ === Object.prototype  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">JSON.construrctor == Object //true</span></span></div></div><div><br/></div><div>上面说的函数对象当然包括自定义的。如下</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">// 函数声明</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function Person() {}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">// 函数表达式</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var Perosn = function() {}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(Person.__proto__ === Function.prototype) // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(Man.__proto__ === Function.prototype)    // true</span></span></div></div><div><br/></div><div>这说明什么呢？</div><div><br/></div><div><strong>所有的构造器都来自于 <code><span style="font-family: 微软雅黑;">Function.prototype</span></code>，甚至包括根构造器<code><span style="font-family: 微软雅黑;">Object</span></code>及<code><span style="font-family: 微软雅黑;">Function</span></code>自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind</strong></div><div><b><code><span style="font-family: 微软雅黑;">Function.prototype</span></code>也是唯一一个<code><span style="font-family: 微软雅黑;">typeof XXX.prototype</span></code>为 <code><span style="font-family: 微软雅黑;">function</span></code>的<code><span style="font-family: 微软雅黑;">prototype</span></code></b>。其它的构造器的<code><span style="font-family: 微软雅黑;">prototype</span></code>都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Function.prototype) // function</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Object.prototype)   // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Number.prototype)   // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Boolean.prototype)  // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof String.prototype)   // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Array.prototype)    // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof RegExp.prototype)   // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Error.prototype)    // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Date.prototype)     // object</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(typeof Object.prototype)   // object</span></span></div></div><div><br/></div><div>噢，上面还提到它是一个空的函数，<code><span style="font-family: 微软雅黑;">console.log(Function.prototype)</span></code> 下看看</div><div><br/></div><div>知道了所有构造器（含内置及自定义）的<code><span style="font-family: 微软雅黑;">__proto__</span></code>都是<code><span style="font-family: 微软雅黑;">Function.prototype</span></code>，那<code><span style="font-family: 微软雅黑;">Function.prototype</span></code>的<code><span style="font-family: 微软雅黑;">__proto__</span></code>是谁呢？</div><div><br/></div><div>相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>console.log(Function.prototype.__proto__ === Object.prototype) // true</div></div><div><br/></div><div>这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；））</div><div><br/></div><div>最后Object.prototype的<strong>proto</strong>是谁？</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Object.prototype.__proto__ === null // true</span></span></div></div><div><br/></div><div>已经到顶了，为null。</div><div><br/></div><div><br/></div><div style="font-weight: bold; font-size: 15px;">八. Prototype</div><div style="font-weight: bold; font-size: 15px;"><br/></div>
在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code><span style="font-family: 微软雅黑;">prototype</span></code> 属性了。对于 ECMAScript 中的引用类型而言，<code><span style="font-family: 微软雅黑;">prototype</span></code> 是保存着它们所有实例方法的真正所在。换句话所说，诸如 <code><span style="font-family: 微软雅黑;">toString()</span></code>和 <code><span style="font-family: 微软雅黑;">valuseOf()</span></code> 等方法实际上都保存在 <code><span style="font-family: 微软雅黑;">prototype</span></code> 名下，只不过是通过各自对象的实例访问罢了。
<div><p>——《JavaScript 高级程序设计》第三版 P116</p></div><div><br/></div><div>我们知道 JS 内置了一些方法供我们使用，比如：<br/>
对象可以用 <code><span style="font-family: 微软雅黑;">constructor/toString()/valueOf()</span></code> 等方法;<br/>
数组可以用 <code><span style="font-family: 微软雅黑;">map()/filter()/reducer()</span></code> 等方法；</div><div>数字可用用 <code><span style="font-family: 微软雅黑;">parseInt()/parseFloat()</span></code>等方法；</div><div><br/></div><div><b>当我们创建一个函数时：</b></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div>var Person = new Object()</div></div><div><br/></div><div><code><span style="font-family: 微软雅黑;">Person</span></code> 是 <code><span style="font-family: 微软雅黑;">Object</span></code> 的实例，所以 <code><span style="font-family: 微软雅黑;">Person</span></code> <strong>继承</strong>了<code><span style="font-family: 微软雅黑;">Object</span></code> 的原型对象<code><span style="font-family: 微软雅黑;">Object.prototype</span></code>上所有的方法：</div><div><img src="http://upload-images.jianshu.io/upload_images/1430985-99ba7f98c0bd06cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="cursor: zoom-in;height:auto;" width="613"></img></div><div><br/></div><div><strong>Object 的每个实例都具有以上的属性和方法。</strong><br/>
所以我可以用 <code><span style="font-family: 微软雅黑;">Person.constructor</span></code> 也可以用 <code><span style="font-family: 微软雅黑;">Person.hasOwnProperty</span></code>。</div><div><br/></div><div><b>当我们创建一个数组时：</b></div><div><br/></div><div><code><span style="font-family: 微软雅黑;">var num = new Array()</span></code></div><div><code><span style="font-family: 微软雅黑;">num</span></code> 是 <code><span style="font-family: 微软雅黑;">Array</span></code> 的实例，所以 <code><span style="font-family: 微软雅黑;">num</span></code> <strong>继承</strong>了<code><span style="font-family: 微软雅黑;">Array</span></code> 的原型对象<code><span style="font-family: 微软雅黑;">Array.prototype</span></code>上所有的方法：</div><div><img src="http://upload-images.jianshu.io/upload_images/1430985-764149fe4df24bd6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="cursor: zoom-in;height:auto;" width="584"></img></div><div><br/></div><div>我们可以用一个 ES5 提供的新方法：<code><span style="font-family: 微软雅黑;">Object.getOwnPropertyNames，</span></code>获取所有（<strong>包括不可枚举的属性</strong>）的属性名<strong>不包括 <code><span style="font-family: 微软雅黑;">prototy</span></code> 中的属性</strong>，返回一个数组：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var arrayAllKeys = Array.prototype; // [] 空数组</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性)</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(Object.getOwnPropertyNames(arrayAllKeys));</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">/* 输出：</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">[&quot;length&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;pop&quot;, &quot;push&quot;,</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">&quot;concat&quot;, &quot;reverse&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;slice&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;filter&quot;, &quot;forEach&quot;,</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">&quot;some&quot;, &quot;every&quot;, &quot;map&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;,</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">&quot;entries&quot;, &quot;keys&quot;, &quot;copyWithin&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;fill&quot;]</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">*/</span></span></div></div><div><br/></div><div>这样你就明白了随便声明一个数组，它为啥能用那么多方法了。</div><div><br/></div><div>细心的你肯定发现了<code><span style="font-family: 微软雅黑;">Object.getOwnPropertyNames(arrayAllKeys)</span></code> 输出的数组里并没有 <code><span style="font-family: 微软雅黑;">constructor/hasOwnPrototype</span></code>等<strong>对象的</strong>方法（你肯定没发现）。</div><div>但是随便定义的数组也能用这些方法：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var num = [1];</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(num.hasOwnPrototype()) // false (输出布尔值而不是报错)</span></span></div></div><div><p>因为<code><span style="font-family: 微软雅黑;">Array.prototype</span></code> 虽然没这些方法，但是它有原型对象（<code><span style="font-family: 微软雅黑;">__proto__</span></code>）：</p></div><div><code><span style="font-family: 微软雅黑;">// 上面我们说了 Object.prototype 就是一个普通对象。</span></code></div><div><code><span style="font-family: 微软雅黑;">Array.prototype.__proto__ == Object.prototype</span></code></div><div><br/></div><div>所以 <code><span style="font-family: 微软雅黑;">Array.prototype</span></code> 继承了对象的所有方法，当你用<code><span style="font-family: 微软雅黑;">num.hasOwnPrototype()</span></code>时，JS 会先查一下它的构造函数 （<code><span style="font-family: 微软雅黑;">Array</span></code>） 的原型对象 <code><span style="font-family: 微软雅黑;">Array.prototype</span></code> 有没有有<code><span style="font-family: 微软雅黑;">hasOwnPrototype()</span></code>方法，没查到的话继续查一下 <code><span style="font-family: 微软雅黑;">Array.prototype</span></code> 的原型对象 <code><span style="font-family: 微软雅黑;">Array.prototype.__proto__</span></code>有没有这个方法。</div><div><b><br/></b></div><div><b>当我们创建一个函数时：</b></div><div><b><br/></b></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var f = new Function(&quot;x&quot;,&quot;return x*x;&quot;);</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">//当然你也可以这么创建 f = function(x){ return x*x }</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(f.arguments) // arguments 方法从哪里来的？</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(f.call(window)) // call 方法从哪里来的？</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(Function.prototype) // function() {} （一个空的函数）</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(Object.getOwnPropertyNames(Function.prototype));</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">/* 输出</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">[&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;constructor&quot;, &quot;bind&quot;, &quot;toString&quot;, &quot;call&quot;, &quot;apply&quot;]</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">*/</span></span></div></div><div><br/></div><div>我们再复习第八小节这句话：</div><div><br/></div><div><u>所有<strong>函数对象</strong><strong>proto</strong>都指向 <code><span style="font-family: 微软雅黑;">Function.prototype</span></code>，它是一个空函数（Empty function）</u></div><div><p>嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的<strong>函数对象</strong>都能用，比如:<br/></p></div><div><img src="http://upload-images.jianshu.io/upload_images/1430985-16bff45efb958d74.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="cursor: zoom-in;height:auto;" width="355"></img></div><div><br/></div><div>如果你还没搞懂啥是函数对象？</div><div><br/></div><div>建议你可以再复习下为什么：</div><div style="margin-left:40px;"><br/></div><b><code><span style="font-family: 微软雅黑;">Function.prototype</span></code></b> <i>是唯一一个typeof XXX.prototype为 “function”的prototype</i><div><br/></div><div>我猜你肯定忘了。</div><div><br/></div><div><h3>九. 复习一下</h3><p>第八小节我们总结了：</p><pre><span style="font-family: 微软雅黑;"><b><code><span style="font-family: 微软雅黑;">所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function）</span></code></b></span></pre><p>但是你可别忘了在第三小节我们总结的：</p></div><div><b><code><span style="font-family: 微软雅黑;">所有对象的 __proto__ 都指向其构造器的 prototype</span></code></b></div><div><br/></div><div>我们下面再复习下这句话。</div><div><br/></div><div>先看看 JS 内置构造器：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var obj = {name: 'jack'}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var arr = [1,2,3]</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var reg = /hello/gvar date = new Datevar err = new Error('exception')</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);"><br/></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(obj.__proto__ === Object.prototype) // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(arr.__proto__ === Array.prototype)  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(reg.__proto__ === RegExp.prototype) // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(date.__proto__ === Date.prototype)  // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(err.__proto__ === Error.prototype)  // true</span></span></div></div><div><p>再看看自定义的构造器，这里定义了一个 <code><span style="font-family: 微软雅黑;">Person</span></code>：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function Person(name) {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.name = name;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var p = new Person('jack')</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(p.__proto__ === Person.prototype) // true</span></span></div></div><div><p><code><span style="font-family: 微软雅黑;">p</span></code> 是 <code><span style="font-family: 微软雅黑;">Person</span></code> 的实例对象，<code><span style="font-family: 微软雅黑;">p</span></code> 的内部原型总是指向其构造器 <code><span style="font-family: 微软雅黑;">Person</span></code> 的原型对象 <code><span style="font-family: 微软雅黑;">prototype</span></code>。</p><p>每个对象都有一个 <code><span style="font-family: 微软雅黑;">constructor</span></code> 属性，可以获取它的构造器，因此以下打印结果也是恒等的：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function Person(name) {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">     this.name = name</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var p = new Person('jack')</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(p.__proto__ === p.constructor.prototype) // true</span></span></div></div><div><p>上面的<code><span style="font-family: 微软雅黑;">Person</span></code>没有给其原型添加属性或方法，这里给其原型添加一个<code><span style="font-family: 微软雅黑;">getName</span></code>方法：</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">function Person(name) {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    this.name = name</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">// 修改原型</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">Person.prototype.getName = function() {}</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">var p = new Person('jack')</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(p.__proto__ === Person.prototype) // true</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">console.log(p.__proto__ === p.constructor.prototype) // true</span></span></div></div><div><br/></div><div>可以看到<code><span style="font-family: 微软雅黑;">p.__proto__</span></code>与<code><span style="font-family: 微软雅黑;">Person.prototype</span></code>，<code><span style="font-family: 微软雅黑;">p.constructor.prototype</span></code>都是恒等的，即都指向同一个对象。</div><div><br/></div><div>如果换一种方式设置原型，结果就有些不同了：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">function Person(name) {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    this.name = name</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">// 重写原型</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">Person.prototype = {</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    getName: function() {}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var p = new Person('jack')</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(p.__proto__ === Person.prototype) // true</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(p.__proto__ === p.constructor.prototype) // false</span></span></span></div></div><div><br/></div><div>这里直接重写了 <code><span style="font-family: 微软雅黑;">Person.prototype</span></code>（注意：上一个示例是修改原型）。输出结果可以看出<code><span style="font-family: 微软雅黑;">p.__proto__</span></code>仍然指向的是<code><span style="font-family: 微软雅黑;">Person.prototype</span></code>，而不是<code><span style="font-family: 微软雅黑;">p.constructor.prototype</span></code>。</div><div><br/></div><div>这也很好理解，给<code><span style="font-family: 微软雅黑;">Person.prototype</span></code>赋值的是一个对象直接量<code><span style="font-family: 微软雅黑;">{getName: function(){}}</span></code>，使用对象直接量方式定义的对象其构造器（<code><span style="font-family: 微软雅黑;">constructor</span></code>）指向的是根构造器<code><span style="font-family: 微软雅黑;">Object</span></code>，<code><span style="font-family: 微软雅黑;">Object.prototype</span></code>是一个空对象<code><span style="font-family: 微软雅黑;">{}</span></code>，<code><span style="font-family: 微软雅黑;">{}</span></code>自然与<code><span style="font-family: 微软雅黑;">{getName: function(){}}</span></code>不等。如下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var p = {}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Object.prototype) // 为一个空的对象{}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Object</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(p.constructor.prototype === Object.prototype) // 为true</span></span></span></div></div><div><br/></div><div style="font-weight: bold; font-size: 15px;"><br/></div><div style="font-weight: bold; font-size: 15px;">十. 原型链（再复习一下：）</div><div><p>下面这个例子你应该能明白了！</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">function Person(){}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var person1 = new Person();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(person1.__proto__ === Person.prototype); // true</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Person.prototype.__proto__ === Object.prototype) //true</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Object.prototype.__proto__) //null</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">Person.__proto__ == Function.prototype; //true</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Function.prototype)// function(){} (空函数)</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var num = new Array()</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(num.__proto__ == Array.prototype) // true</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log( Array.prototype.__proto__ == Object.prototype) // true</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Array.prototype) // [] (空数组)</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Object.prototype.__proto__) //null</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(Array.__proto__ == Function.prototype)// true</span></span></span></div></div><div><p>疑点解惑：</p><ol><li><p><code><span style="font-family: 微软雅黑;">Object.__proto__ === Function.prototype // true</span></code><br/><code><span style="font-family: 微软雅黑;">Object</span></code> 是函数对象，是通过<code><span style="font-family: 微软雅黑;">new Function()</span></code>创建的，所以<code><span style="font-family: 微软雅黑;">Object.__proto__</span></code>指向<code><span style="font-family: 微软雅黑;">Function.prototype</span></code>。（参照第八小节：「所有函数对象的<code><span style="font-family: 微软雅黑;">__proto__</span></code>都指向<code><span style="font-family: 微软雅黑;">Function.prototype</span></code>」）</p></li><li><p><code><span style="font-family: 微软雅黑;">Function.__proto__ === Function.prototype // true</span></code><br/><code><span style="font-family: 微软雅黑;">Function</span></code> 也是对象函数，也是通过<code><span style="font-family: 微软雅黑;">new Function()</span></code>创建，所以<code><span style="font-family: 微软雅黑;">Function.__proto__</span></code>指向<code><span style="font-family: 微软雅黑;">Function.prototype</span></code>。</p><blockquote><p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL生万物）<br/>
正如《道德经》里所说“无，名天地之始”。</p></blockquote></li><li><p><code><span style="font-family: 微软雅黑;">Function.prototype.__proto__ === Object.prototype //true</span></code></p><blockquote><p>其实这一点我也有点困惑，不过也可以试着解释一下。<br/><code><span style="font-family: 微软雅黑;">Function.prototype</span></code>是个函数对象，理论上他的<code><span style="font-family: 微软雅黑;">__proto__</span></code>应该指向 <code><span style="font-family: 微软雅黑;">Function.prototype</span></code>，就是他自己，自己指向自己，没有意义。<br/>
JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向<code><span style="font-family: 微软雅黑;">Object.prototype</span></code>。<code><span style="font-family: 微软雅黑;">Object.prototype.__proto__ === null</span></code>，保证原型链能够正常结束。</p></blockquote></li></ol><h3>十一 总结</h3><ul><li>原型和原型链是JS实现继承的一种模型。</li><li>原型链的形成是真正是靠<code><span style="font-family: 微软雅黑;">__proto__</span></code> 而非<code><span style="font-family: 微软雅黑;">prototype</span></code></li></ul><p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？</p></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var animal = function(){};</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var dog = function(){};</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">animal.price = 2000;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">dog.prototype = animal;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var tidy = new dog();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(dog.price) //undefined</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(tidy.price) // 2000</span></span></span></div></div><div><br/></div><div>这里解释一下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var dog = function(){};<br/>
dog.prototype.price = 2000;<br/>
var tidy = new dog();<br/>
console.log(tidy.price); // 2000<br/>
console.log(dog.price); //undefined</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">var dog = function(){};<br/>
var tidy = new dog();<br/>
tidy.price = 2000;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">console.log(dog.price); //undefined</span></span></span></div></div><div><p>这个明白吧？想一想我们上面说过这句话：</p></div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">实例（<code><span style="font-family: 微软雅黑;">tidy</span></code>）和 原型对象（<code><span style="font-family: 微软雅黑;">dog.prototype</span></code>）存在一个连接。不过，要明确的真正重要的一点就是，这个<b>连接存在于实例（<code><span style="font-family: 微软雅黑;">tidy</span></code>）与构造函数的原型对象（<code><span style="font-family: 微软雅黑;">dog.prototype</span></code>）之间，而不是存在于实例（<code><span style="font-family: 微软雅黑;">tidy</span></code>）与构造函数（<code><span style="font-family: 微软雅黑;">dog</span></code>）之间。</b></div><div><b><br/></b></div><div><b>总结：普通对象的__proto__指向这个对象（this）的构造函数的prototype；</b><b>函数对象的__proto__全部都是指向Function的prototype。</b></div><div><b>         </b> <span style="color: rgb(51, 51, 51); font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;"><b>无论是Function的prototype.__proto__还是构造函数的prototype</b></span><span style="color: rgb(51, 51, 51); font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;"><b>.__proto__</b></span> <span style="color: rgb(51, 51, 51); font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;"><b>都指向object.prototype，然后最终object.prototype.__proto__指向null。</b></span></div><div><b>          也可以理解为：功能上讲prototype是给别人用的东西，而且给别人的东西自己不能用，__proto__是借用别人的东西（继承）。</b></div><div><b>          对于所有的对象，都有__proto__属性，这个属性对应该对象的原型。</b></div><div><b>          对于函数对象，除了__proto__属性之外，还有prototype属性，当一个函数被用作构造函数来创建实例时，该函数的prototype属性值将被作为原型赋值给所有对象实例（也就是设置实例的__proto__属性，所以才会说每               个对象的__proto__属性指向该对象构造函数的prototype）</b></div><div><b>          所有的原型对象都有constructor属性，该属性对应创建所有指向该原型的实例的构造函数。</b></div><div><b>          函数对象和原型对象通过prototype和constructor属性进行相互关联。<br/></b></div><div>原型链：因为每个对象和原型都有原型，对象的原型指向原型对象，而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。（终点是object.prototype，即原型链顶部）</div><div><b><br/></b></div></span>
</div></body></html> 