<html>
<head>
  <title>关于dojo类机制（了解即可）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="416"/>
<h1>关于dojo类机制（了解即可）</h1>

<div>
<span><div><p>随着AJAX和RIA技术的发展，JavaScript被广泛的使用，并在开发中发挥着越来越重要的作用。JavaScript提供了特有的类机制，但是在语法习惯上与传统面向对象的语言有很大的不同，这使得不少的JavaScript开发人员感到比较迷惑，而dojo作为功能强大的JavaScript类库，有功能完整的类机制实现。本文将通过实例介绍dojo的类机制，这是dojo提供的一种强大和灵活的功能，其dijit UI组件框架也是以此为基础实现的。</p><h2>1. 使用dojo定义类</h2><p>声明dojo类是通过dojo.declare()方法来实现的，如我们想要定义一个名为com.levinzhang.Person的类，该类有name、age属性和getName、getAge方法：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>dojo.declare(&quot;com.levinzhang.Person&quot;, null,{</div><div>     name:null,</div><div>     age:null,</div><div>     constructor: function(name,age){</div><div>          this.name = name;</div><div>          this.age = age;</div><div>     },</div><div>     getName:function(){</div><div>          return this.name;</div><div>     },</div><div>     getAge:function(){</div><div>          return this.age;</div><div>     }</div><div>});</div></div><div><br/></div><div><p>除了前面提到的属性的和方法以外，在代码中我们还定义了一个名为constructor的方法，这个方法在dojo的类机制中至关重要，当我们实例化该类得到对象的时候，该方法将会被调用，从而完成初始化的操作。</p><p>dojo的declare接受三个参数，分别为类的名称、要继承的父类以及该类的属性和方法。实例化类的语法也很简洁，与实例化普通的JavaScript类并无分别：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var person = new com.levinzhang.Person(&quot;levinzhang&quot;,30);</div><div>alert(person.getName());//将会提示出levinzhang</div></div><div><br/></div><div><br/></div><div><b><span style="font-size: 20px;">2. 实现静态变量</span></b></div><div><p>在常见的面向对象语言中，经常会使用到类层次的静态变量，而通过dojo定义的类也能实现静态变量的需求，不过静态变量仅限于数组和对象类型。</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>staticInfo:{count:0},</div><div>constructor: function(name,age){</div><div>     this.name = name;</div><div>     this.age = age;</div><div>     ++this.staticInfo.count;</div><div>}</div></div><div><br/></div><div><p>如上所示，如果定义了数组和对象，而没有在构造方法中进行修改的话，这个对象将会成为该类的静态属性，测试代码如下：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var person = new com.levinzhang.Person(&quot;levinzhang&quot;,30);</div><div>alert(person.staticInfo.count);//此时将会提示出1</div><div>var person2 = new com.levinzhang.Person(&quot;levin&quot;,30);</div><div>alert(person2.staticInfo.count);//此时将会提示出2</div></div><div><br/></div><div><p>需要注意的两点是：1）对于原始类型的变量如数字、布尔值和字符串，dojo的类机制并没有提供实现静态属性的功能；2）如果定义的数组或对象属性在constructor方法中被重新赋值，那么该属性将不再是静态属性，而是每个实例化对象都持有一份属于自己的备份了。</p><h2>3. 使用dojo实现继承</h2><p>在JavaScript中没有直接实现继承的关键字，因此关于继承有多种的实现方式，代表性的是<a href="http://javascript.crockford.com/inheritance.html">类式继承</a>和<a href="http://javascript.crockford.com/prototypal.html">原型式继承</a>，但是不管哪种继承方式都需要开发人员对JavaScript语言本身有着很深厚的了解。dojo对JavaScript的继承机制进行了很好的封装，可以实现功能强大的类定义，我们将对一些常见的功能进行介绍。</p><p>dojo.declare方法中的第二个参数，是指明要继承的父类的，该参数可以为null（要定义的类没有父类）、单个类（要定义的类继承自一个父类）或数组（要定义的类继承自多个父类）。</p><h3>1） 单继承</h3><p>我们要定义一个名为com.levinzhang.Employee 的类，继承自com.levinzhang.Person，并要添加名为workExperience的属性、重写getName方法等功能：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>dojo.declare(&quot;com.levinzhang.Employee&quot;, com.levinzhang.Person,{</div><div>     workExperience:null,</div><div>     constructor: function(name,age,workExperience){</div><div>          this.workExperience = workExperience;</div><div>     },</div><div>     getWorkExperience:function(){</div><div>          return this.workExperience;</div><div>     },</div><div>     getName:function(){</div><div>          return &quot;Employee:&quot;+this.name;</div><div>     },</div><div>     getInput:function(){</div><div>          return 5000;</div><div>     }</div><div>});</div></div><div><br/></div><div><p>在以上的代码中，我们定义的com.levinzhang.Employee继承了com.levinzhang.Person并添加了自定义的方法。测试代码如下：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var employee = new com.levinzhang.Employee(&quot;levin&quot;,30,4);</div><div>alert(employee.getName());//将提示出Employee:levin</div><div>alert(employee.getWorkExperience());//将提示出4</div><div>alert(employee.getAge());//将提示出30</div></div><div><br/></div><div><p>可以看到在Employee的实例中，我们能够调用父类中定义的方法。而在类的constructor初始化方法中，我们并没有调用父类相关的方法，但是我们成功初始化了name和age两个属性，这是因为dojo会自动调用父类的初始化方法，完成继承要求的相关初始化工作。</p><h3>2） 多继承</h3><p>dojo支持多继承的功能， dojo实现了被Python和很多支持多继承语言使用的C3算法。使用dojo的多继承功能时，需要注意的是：只有数组中的第一个元素会作为真正的父类，而其它的元素则是通过mixin的方式进行属性添加以构建原型链的。</p><p>如我们需要定义一个类来表示公司中的股票持有者（com.levinzhang.Shareholder），而公司中的员工可能也会持有股票，于是我们定义一个名为com.levinzhang.ShareholderEmployee的类继承自com.levinzhang.Shareholder和com.levinzhang.Employee。</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>dojo.declare(&quot;com.levinzhang.Shareholder&quot;, com.levinzhang.Person,{</div><div>     share:null,</div><div>     constructor: function(args){</div><div>          this.share = args.share;</div><div>     },</div><div>     getShare:function(){</div><div>          return this.share;</div><div>     }</div><div>});</div><div>dojo.declare(&quot;com.levinzhang.ShareholderEmployee&quot;, [com.levinzhang.Employee,com.levinzhang.Shareholder],{</div><div>     getInfo:function(){</div><div>          alert(&quot;I'm an Employee with stock.My share is &quot;+this.getShare()+&quot;.&quot;+&quot;My name is &quot;+this.getName()+&quot;.&quot;);</div><div>     }</div><div>});</div></div><div><br/></div><div><p>在以上的代码中，我们调整了原有的初始化传入参数的格式，由传入多个参数改为传入一个简单JavaScript字面量对象的方式（原有的代码也要稍作调整），并通过多继承的方式实现了一个类用来描述持有股票的员工。测试代码如下：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var shareholderEmployee = new com.levinzhang.ShareholderEmployee({name:&quot;levin&quot;,age:30,workExperience:4,share:300}); shareholderEmployee.getInfo(); //将会提示出“I'm an Employee with stock.My share is 300. My name is Employee:levin.”</div></div><div><br/></div><div><p>关于dojo多继承的更多话题，请参考<a href="http://docs.dojocampus.org/">dojo的文档资料</a>。</p><h3>3） 调用父类的方法</h3><p>在编程中，我们经常会遇到在子类的某个方法中需要调用父类的方法来协作完成功能。如我们定义名为com.levinzhang.Manager的类，该类继承自com.levinzhang.Employee类，并重写getInput方法，Manager的收入分为两部分，一部分是与com.levinzhang.Employee相同的固定收入，另一部分是与管理经验相关的其它收入，这样在定义Manager的时候，就需要调用父类的方法，实现方式如下：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>dojo.declare(&quot;com.levinzhang.Manager&quot;, com.levinzhang.Employee,{</div><div>     manageExperience:null,</div><div>     constructor: function(args){</div><div>          this.manageExperience = args.manageExperience;</div><div>     },</div><div>     getInput:function(){</div><div>          var fromBase = this.inherited(arguments);</div><div>          return fromBase+1000*this.manageExperience;</div><div>     }</div><div>});</div></div><div><br/></div><div><p>从以上代码可以看到，通过inherited方法的使用，使得Manager可以调用父类的方法。测试代码如下：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var manager = new com.levinzhang.Manager({name:&quot;levin&quot;,age:30,workExperience:4,manageExperience:2});</div><div>alert(manager.getInput());//7000</div></div><div><br/></div><div><p>在以上的测试代码中，getInput的返回值为7000，说明该值为子类和父类方法共同确定的。</p><p>除了使用inherited来调用父类中的方法以外，从dojo的1.4版本开始提供了链式调用父类方法的功能，能够通过设置自动调用父类的方法，并且支持类似于AOP的before或after配置（dojo正在开发中的1.7版本，提供了更为丰富的AOP功能，我们将会持续关注）。</p><h2>4. Dojo类机制的其它功能</h2><p>除了以上介绍的类定义相关功能以外，dojo还提供了许多的便利的工具类供使用。</p><p>dojo类所生成对象具有一些特有的属性和方法，常见的如isInstanceOf方法和declaredClass属性，isInstanceOf方法判定对象是否为某个类的实例，而declaredClass属性则能够表明该对象的声明类是什么。如：</p></div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var manager = new com.levinzhang.Manager({name:&quot;levin&quot;,age:30,workExperience:4,manageExperience:2}); alert(manager.isInstanceOf(com.levinzhang.Employee));//提示为true</div><div>alert(manager.isInstanceOf(com.levinzhang.Person));//提示为true</div><div>alert(manager.declaredClass);//提示为“com.levinzhang.Manager”</div></div><div><br/></div><div><p>类机制还涉及到的包管理等功能，限于篇幅，不再展开叙述，感兴趣的读者可以参考dojo的在线文档或图书。</p><h2>5. 小结</h2></div><div><br/></div><div>JavaScript本身的类机制比较复杂，对开发人员有着较高的要求，而dojo提供了功能强大的类功能，有些降低了开发的难度。本文简单介绍了dojo类机制的基本功能，包括类定义、继承、静态属性等，这是dojo最基础也是最核心的内容之一，dojo的许多高级功能都是基于此来实现的，因此了解这部分功能的使用方式甚至源码实现对于整体把握dojo框架都大有裨益。</div></span>
</div></body></html> 